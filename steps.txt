App opens connect to socket server pass user id in query when making connection
data:
  userId
check is user exists in our database or not,
if does not EMIT -> set-user-error (need to change event name) ('User does not exist')
set socket.data.user = user (User document will be stored here)
By this steps we can say that user is online
add user's socket to the rooms (Rooms will be created based upon CONVERSATION database, all the conversation in which user id is part of members field) in which user is allowed to be
Server Side:
  ON -> diconnect
    No need to do anything
    This event will be called when user closes the app
  ON -> new-conversation: we can remove this event listener and do this steps on new-message listener
    data:
      user1: current_user
      user2: other user of conversation
    create new CONVERSATION
    create a room with the same id as conversation._id
    add current user's socket id to this room and check other conversation.members if they are ONLINE or not,
    if ONLINE then add them in this room (Using their user.socket) else on OFFLINE we will not do anything
    EMIT -> new-conversation
      send:
        conversation object
  ON -> new-message:
    data:
      user1: current_user
      conversation: id of the conversation in which user wants to send message
      message: string (message which user wants to send)
    Add message in message database
    EMIT -> new-message:
      Emit this added new MESSAGE to room of this conversation (room.id === conversation._id)
      send:
        message object 
    before emiting this event we need to check whether all users part of this conversation are online or not, 
    if not then we send a fcm push notification to notify them or else part emit will send the message to the user who is ONLINE
    ONLINE and OFFLINE can be checked using io.fetchSockets() which gives us a list of all connected sockets and each socket
    will contain user as data (in socket.data.user, which is set in set-user event on server side) and based upon user value
    we can identify whether user is associated with any socket or not

Client Side:
While making connection pass user id in the query of URL
  EMIT -> new-conversation:
    send:
      userId (With whome we want to start conversation)
  EMIT -> new-message:
    send:
      conversation: _id
      message: string
  ON -> new-conversation:
    data:
      complete conversation object
    Add this conversation to list of conversation this will contain no messages (Any conversation with empty messages will not be shown)
  ON -> new-message:
    data:
      complete message object
    Add this message into its relevant conversation

DATABASE MODELS:
  CONVERSATION:
    _id: uuid
    members: [array of users]
    created_at: date
  MESSAGE:
    _id: uuid
    conversation: _id to ref CONVERSATION
    sender: _id to ref Users (Need to add validation whether user id part of conversation or not)
    message: string
    created_at: date
    status: seen, unseen



API:
getConversations - list of all conversation in which user is part of
getConversationDetail - detail of a conversation document
getMessages - list of messages from a conversation

Socket events:
new_conversation - create conversation
update_conversation - update conversation
delete_conversation - delete conversation
new_message - new message into a conversation
update_message - edit the message
delete_message - delete a message
seen_message - add the user in seen/unseen status array, when user see the message

Socket Error Events:
new_conversation_error
update_conversation_error
delete_conversation_error
new_message_error
update_message_error
delete_message_error
seen_message_error

Requirement and Estimates:
  API:
    getConversations - list of all conversation in which user is part of
    getConversationDetail - detail of a conversation document
    getMessages - list of messages from a conversation

  Server:
    initial setup (integrating socket.io) - 2hr
    handling initial socket connection and set data - 2hr
    new_conversation - create conversation - 6hr
    update_conversation - update conversation - 2hr
    delete_conversation - delete conversation - 1hr
    new_message - new message into a conversation - 6hr
    update_message - edit the message - 2hr
    delete_message - delete a message - 1hr
    seen_message - add the user in seen status array, when user see the message - 4hr
    new_conversation_error - 1hr
    update_conversation_error - 1hr
    delete_conversation_error - 1hr
    new_message_error - 1hr
    update_message_error - 1hr
    delete_message_error - 1hr
    seen_message_error - 1hr

  App:
    initial setup (integrating socket.io-client) - 4hr
    Create main screen for conversations to show a list of conversations - 5hr
    Create messages screen to show a list of messages from a conversation - 7hr
    handle socket events of conversation and update the conversations screen - 19hr
    handle socket events of messages and update the messages accordingly - 19hr
      Total: 46hr for app (Estimates are based upon api and socket being in ready state)
